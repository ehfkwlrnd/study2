#include <iostream>
using namespace std;

int main()
{
	int m;
	scanf("%d", &m);
	int B[m] = {0,};
	double num;
	while(~scanf("%lf", &num)) B[(int)(m*num+0.0000001)]++;
	for(int i = 0; i < m; i++) printf("%d ", B[i]);
}

//해설
/*
논리 :  
1 <= k <= m 에 대해 
각bk은구간 [(k-1)/m,  k/m) 이다.
배열 B는 m개의 원소를 갖고, B[k-1]는 bk에 속하는 an의 개수이다. 

임의의 an에 대해 어떤 bk가 존재하여 an이bk에 속하므로
	(k-1)/m <= an < k/m 
이 성립한다.

즉, k-1 <= m*an < k 이므로  
	[m*an] = k-1   ([x]는 x보다 크지 않은 최대 정수) 
이다.

0이상인 x에 대해 [x]는(int)x로 표현하도록 하자. 
따라서 B[(int)(m*an)]=B[k-1]에 1을 증가시키면 an이 bk에 속함을 카운트 할 수 있다.

컴퓨팅적 문제 :
부동소수점을 원리를 이해 한다면 0.3 * 3이 0.9보다 작음을 이해할 수 있을 것이다.
마찬가지로 0.1을 10번 더한값은 1보다 작다. (하지만 10 * 0.1 의 결과값은 1이다.)

그럼 어떤 경우에 오류가 생길까.
m=625라 하자. an=0.0048 이라면 625*0.0048=3 이므로 
논리적으로 B[3]=b4=[0.0048, 0.0064)에 속함을 알 수 있다. 

그런데 an=0.0048의 실제값은 0.00479999999999999957950.. 의 반올림 값이다.
그 결과 m*an= 2.99999999999999955591079.. 이며 
[m*an]=2가 되어 논리적으로 예상한 값과 다르게 나오는 것을 확인할 수 있다.

수학적인 계산에 의한 값이 m*an = x 라할 때, 
부동소수점에 의한 오류는 m*an = x + e 또는 x - e 를 발생시킨다는 점이다. (0 < e <= 4*10^-11)

이 때 [x+e]=[x]이므로 x-e인 케이스를 해결하기 위한 아이디어를 생각해야 한다. 
이에 대한 해결법으로는 10^-7을 더해줘서 오차를 조정하는 것이다. 
그렇다면 [x+e]=[x+e+10^-7]=[x] 이므로 10^-7을 더하더라도 문제가 생기지 않는다.
또한 [x-e]=[x]-1 인 경우에 [x-e+10^7]=[x] 임도 알 수 있다. 
(an의 입력값은 10^-6 이상이므로 x = m*an의 값도 10^-6 이상이다.)
*/ 
