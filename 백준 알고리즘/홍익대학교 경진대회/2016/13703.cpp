#include <iostream>
using namespace std;

int k, n;
long long A[64][65];

int main()
{
	cin >> k >> n;
	for(int j = 0; j <= n; j++){
		A[0][j] = (long long)1 << j;
	}
	for(int j = 1; j <= n; j++){
		for(int i = 1; i <= n; i++){
			A[i][j] = A[i-1][j-1] + A[i+1][j-1];
		}
	}
	cout << ((long long)1 << n) - A[k][n];
}

//해설
/*
논리 :
만약 모든 경우의 수에 대해 수면보다 밑인지 아닌지 판단하여 
경우의 수를 센다면 시간 복잡도는 O(2^n)이다. 
당연히 이런 알고리즘을 사용하면 시간초과 에러를 만나게 된다.

어떻게 아이디어를 뽑아내면 좋을까.
우선 k=2, n=3 인 경우를 보자.
이 상황에서 물벼룩은 위 또는 아래로 이동할 수 있다.
위로 가면 k=1, n=2 인 상황이 되고, 아래로 가면 k=3, n=2인 상황이 된다.
그런데 이 두 상황에서 살아남는 경우의 수를 합하면 k=2, n=3에서 살아남는 경우의 수와 같음을 알 수 있다.
즉, C[k, n] = C[k-1, n-1] + C[k+1, n-1] 인 것이다.
위의 코드에선 배열에 살아남는 경우 대신 죽는 경우의 수를 입력했다. 어쨋건 논리는 똑같이 작용한다. 

n이 주어지면 모든 경우의 수는 2^n이며, k=0일 때는 모든 경우의 수가 죽는 경우 이므로
초기값으로 C[0, i] = 2^i 을 줬다.
그 후 k=1, n=1부터 시작하여 각 n에 대해 각 k를 조사하면 우리가 원하는 C[k, n]을 얻을 수 있다. 
이렇게 동적프로그래밍을 통해 코드를 개선하면 시간 복잡도는 O(k*n) 이다.

컴퓨팅적 문제 : 
0 <= n <= 63 이므로 경우의 수는 최대 2^63이 될 수 있다.
따라서 배열을 long long타입으로 선언했다.
또한 상수 1은 기본적으로 int타입으로 컴파일 되므로,
1 << 63 같은 경우엔 오버플로우로 인해 제대로 된 값을 없을 수 없다. 
따라서 (long long)1 << n 과 같이 코드를 입력해야 한다. 

또, cout << (long long)1 << n - A[k][n]; 은 왜 문제가 되는가.
(long long)1 << n 으로 인식하지 않고 1과 n-A[k][n]을 출력하는 것을 잘못 인식하기 때문이다. 
따라서 <<이 cout의 연속 출력이 아닌 shift연산임을 알려주기 위해 ((long long)1 << n)처럼 괄호로 묶어준다. 
*/ 
