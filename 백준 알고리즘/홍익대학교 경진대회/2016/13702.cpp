#include <iostream>
using namespace std;

int N, K;
int A[10000];

bool possible(int q){
	int count = 0;
	for(int i = 0; i < N; i++)count += A[i]/q;
	return count >= K;
}

int main()
{
	cin >> N >> K;
	for(int i = 0; i < N; i++) cin >> A[i];
	long long p = 1;
	long long q = ~(1 << 31);
	long long r = q;
	
	while(p != q || q != r){
		if(possible(q)) {
			p = q;	
			q = (p+r)/2 + 1;
		}
		else {
			r = q-1;	
			q = (p+r)/2;
		}
		
	}
	cout << q;
}

//해설
/*
논리 :
임의의 용량 w로 K명에게 나눠줄 수 있는지 어떻게 확인할 수 있을까.
각 주전자를 Ai으로 표현해보자.
w씩 나눠줬을 때 최대 나눠줄 수 있는 인원수 y를 구하는 방법은 다음과 같다.
	y = [A1/w] + [A2/w] + ... + [A3/w]   ([x]는 x보다 크지 않은 최대 정수) 
y >= K 이면 나눠줄 수 있음을 알 수 있다.
또, 이 판정 알고리즘은 O(n)임을 알 수 있다. 
이제 이 논리를 사용하여 용량 w로 나눠줄 수 있는지 판정하는 함수를 possible(w)로 정의하겠다. 

K명에게 나눠줄 수 있는 최대의 막걸리 용량을 x라고 하자.
각 주전자를 배열 A으로 표현해보자. (각 A[i] <= 2^31-1 = MAX) 
	x*K <= A[1]+A[2]+...+A[N] <= N*MAX
이므로 x <= MAX 이다. (왜냐하면 N <= K) 
즉, 간단히 생각해보면 1부터 MAX까지 1씩 증가시키며 possible(x)로 조사하면 
처음으로 false값이 되는 x보다 1작은 값이 해가 됨을 알 수 있다.
그런데 이렇게 하면 시간복잡도가 O(n*m)인데 m은 최대 2^31 이므로 시간초과 에러가 뜨게 된다. 

생각을 다시 해보면 x보다 작은 숫자에 대해서는 possible(x)는 true지만
x보다 큰 숫자에 대해서는 false임을 알 수 있다.
이 문제는 무엇과 닮았는가. 바로 업-다운(up-down) 문제와 닮았다. 
업다운 문제에서 해를 찾는 가장 빠른 방법은 바로 이진탐색이다.
따라서 이진탐색을 통해 시간복잡도를 O(n*log(m))으로 향상 시킬 수 있다.

컴퓨팅적 문제 :
이진탐색을 작성하는데 자주 곤란을 겪는 경우를 볼 수 있다.
	1. p, q, r 중 누구를 possible에 검사를 할 것 인가.
	2. 언제 이진탐색에서 빠져 나와야 하는가. p가 q와 같을 때? q가 r과 같을 때?

이진탐색의 큰 논리이다. 
possible(q)를 검사하도록 한다. 
p, q, r은 크기 순으로 배정되어 있으며 possible의 결과값에 따라 p 또는 r이 q값 으로 이동한다.
그리곤 q는 p와 r의 중간값으로 이동한다. 

이진탐색의 계산적인 부분을 설명하겠다. 
와 같은 이진탐색에 대한 큰 논리를 통해 해에 빠르게 접근하지만,
p, q, r의 거리가 1이하로 근접했을 때 문제가 생긴다.
예를 들어 위 코드와 달리 아래와 같은 코드는 어떤 문제가 생길까.
while
	if(possible(q)) p = q;
	else r = q;
	q = (p+q)/2;
	
p, q, r이 각각 x-2, x-1, x 라 하자.
종료 조건 없이 진행하면, 아래와 같이 진행될 것 이다.
	x-2, x-1, x
	x-1, x-1, x
	x-1, x-1, x
 	...
어, 그럼 종료조건을 p와 q가 같을 떄로 정하고 r을 출력하면 되는게 아닌가? 
다른 케이스에 대해서도 확인해 보자.
 	x-1, x, x+1
	x, x, x+1
	x, x, x+1
	...
	
	x, x+1, x+2 
	x, x, x+1 
	x, x, x+1
	...
이 두 가지 케이스에 대해서는 p와 q가 같을 때 종료하면 되지만, q를 출력해야 한다. 
이 때문에 종료 조건과 출력변수가 일관성을 갖기 힘들다.
즉, r = q-1, q = (p+r)/2+1 과 같은 코드는 이러한 종료조건과 출력변수의 일관성을 위한 조작이라 볼 수 있다. 

마지막으로 p, q, r의 변수타입을 long long으로 설정한 이유를 설명하겠다.
만약 int타입으로 설정하게 되면 p+q > 2^31인 경우에는 오버플로우로 인한 계산문제가 생기기 때문이다. 
*/ 
