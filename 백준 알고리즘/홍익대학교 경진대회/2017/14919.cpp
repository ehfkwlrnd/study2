#include <iostream>
using namespace std;

int main()
{
	int m;
	scanf("%d", &m);
	int B[m] = {0,};
	double num;
	while(~scanf("%lf", &num)) B[(int)(m*num+0.0000001)]++;
	for(int i = 0; i < m; i++) printf("%d ", B[i]);
}

//해설
/*
논리 :  
1 <= k <= m 에 대해 
각bk은구간 [(k-1)/m,  k/m) 이다.
배열 B는 m개의 원소를 갖고, B[k-1]는 bk에 속하는 an의 개수이다. 

임의의 an에 대해 어떤 bk가 존재하여 an이bk에 속하므로
	(k-1)/m <= an < k/m 
이 성립한다.

즉, k-1 <= m*an < k 이므로  
	[m*an] = k-1   ([x]는 x보다 크지 않은 최대 정수) 
이다.

0이상인 x에 대해 [x]는(int)x로 표현하도록 하자. 
따라서 B[(int)(m*an)]=B[k-1]에 1을 증가시키면 an이 bk에 속함을 카운트 할 수 있다.

컴퓨팅적 문제 :
부동소수점을 원리를 이해 한다면 0.3 * 3이 0.9보다 작음을 이해할 수 있을 것이다.
마찬가지로 0.1을 10번 더한값은 1보다 작다. (하지만 10 * 0.1 의 결과값은 1이다.)

그럼 어떤 경우에 오류가 생길까.
m=625라 하자. an=0.0048 이라면 625*0.0048=3 이므로 
논리적으로 B[3]=b4=[0.0048, 0.0064)에 속함을 알 수 있다. 

그런데 an=0.0048의 실제값은 0.00479999999999999957950.. 이다. 
그 결과 m*an= 2.99999999999999955591079.. 이며 
[m*an]=2가 되어 논리적으로 예상한 값과 다르게 나오는 것을 확인할 수 있다.

즉, 문제점은 논리적인 계산에 의한 값이 m*an = x 라할 때, 
부동소수점에 의한 계산값은 m*an = x + e 또는 x - e 를 발생시킨다는 점이다. (e는 10^-7 보다 작고 0보다 큰 아주 작은 수)

이 때 an의 입력값은 소수점 6자리 까지이 이므로 x = m*an의 값도 소수점 6자리 밑으로는 0 이다.
그러므로 [x+e]=[x]임을 알 수 있다. 
예를들어  x = 0.999999라 하더라도 x+e = 0.999999000000345..와 같은 수가 된다면 [x+e]=[x] 이다. 
따라서 x-e인 케이스를 해결하기 위한 아이디어를 생각해야 한다. 

이에 대한 해결법으로는 10^-7을 더해줘서 오차를 조정하는 것이다. 
e는 10^-7 보다 아주 작은 수 라는 점을 상기해보자. [x-e]=[x]-1 인 경우에 [x-e+10^7]=[x] 임을 알 수 있다.
이에 대한 예시는 위에 m=625, an=0.0048으로 제시되어 있다.
또한 [x+e]=[x+e+10^-7]=[x] 이므로 10^-7을 더하더라도 문제가 생기지 않는다.
*/ 
